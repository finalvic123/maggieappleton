---
title: 'Learnable, Visual Programming Patterns'
slug: learnable-programming
startDate: 2021-01-12
updated: 2021-04-02
published: true
type: ['note']
topics: ['Visual Explanation', 'Web Development', 'JavaScript', 'Collaborative Learning']
growthStage: 'Budding'
---

<IntroParagraph>
    
Bret Victor coined the term <b>Learnable Programming</b> in his <a href="http://worrydream.com/LearnableProgramming">canonical essay</a> lamenting the current state of programming education. Victor has a few concerns with the way most of us learn to code. Mainly that the learning environments we drop people into are poorly designed.

</IntroParagraph>

These environments tend to look something like this:

<TwoCol imgmargin="1em auto" divwidth="590px">

<BasicImage src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174726/maggieappleton.com/notes/learnable-programming/learnprog_1_nsfflv.png" alt="repl.it slpit screen interface" />
<BasicImage src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174727/maggieappleton.com/notes/learnable-programming/learnprog_4_dk82q8.png" alt="codesandbox split screen interface" />
<BasicImage src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174727/maggieappleton.com/notes/learnable-programming/learnprog_5_tlycev.png" alt="free code camp split screen interface" />
<BasicImage src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174726/maggieappleton.com/notes/learnable-programming/learnprog_3_bkslg8.png" alt="khan academy split screen interface" />

</TwoCol>

They're your standard column-based "live coding" interfaces popular across the industry. You write code into one section, and hopefully get the output you expected in another. Syntax is abstracted away from the elements it affects.

---

It's easy to see why these linear, text-based interfaces _seem_ like the best approach. They look identical to the standard interfaces the whole development industry uses to programme.

All development takes place in an isolated text window. If you type the correct sequence of words and symbols into that editor, the correct series of events happens somewhere out of view. Functions run in an unseen JavaScript engine, interface elements appear in the browser, and somewhere a value changes in a distant database. You only get the end result. To see anything happening in the middle, you have to `console.log` out data at each step of the way. The industry has accepted flying blind as standard operating procedure.

<FullWidthImage width="880px" src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174727/maggieappleton.com/notes/learnable-programming/learnprog_2_ieudi6.png" alt="The interface of VS Code – one of the most popular environments for professional programming" showalt />

So we're training people in the same kind of environment they'll be working in professionally. In the just-get-a-job-mindset that's an excellent approach. But Victor isn't talking about the ideal way to learn programming in the short-term, bootcampy world view. When he talks about these environments as inadequate, he's referencing a much larger paradigm shift around how we should design human-computer interfaces. 

He's pointing out that the standard text-based, disembodied, non-graphical interfaces we all put up with are unintuitive to humans who live in a highly visual, spatial, embodied world. While most of our modern user interfaces have graduated to a graphical, 3D space-based system, programming is staunchly attached to the linear text paradigm. 

There's good reason for this. While many people have tried to develop [visual programming languages](https://en.wikipedia.org/wiki/Visual_programming_language), they've largely failed to gain traction. There's lots of [well-reasoned](https://www.outsystems.com/blog/posts/visual-programming-language/) [arguments](https://dzone.com/articles/visual-programming-why-its-a-bad-idea) [explaining](https://mikehadlow.blogspot.com/2018/10/visual-programming-why-its-bad-idea.html) why it's so difficult to design visual systems complex and extensible enough to programme in, so I won't repeat them here.
The fact is that our current visual languages aren't sophisticated enough to do the job, and  we're a long way from any system that could.

While visual programming isn't great for the scale of complexity professional programmers deal with, it's _ideal_ for people who are learning to code. When we simply need to explain what's happening under the hood, graphical representations are the best way to help people build clear mental models.

---

## Principles of Learnable Programming 

Victor outlined a set of principles he believed all learnable programming environments should follow. He argues any good educational platform should allow learners to...
1. **Read the vocabulary** of a language by making clear what each keyword and function does
2. **Follow the flow** of what happens at each stage in executing a programme 
3. **See the state** as the programme changes variables over time
4. **Create by reacting** to how the programme behaves
5. **Create by abstracting** from the simple to the complex

Most of these are explicitly **visual**. We need to make what's happening in the programme _readable_ through visual representations of each syntax element, variable, and change of state over time. As Victor puts it:

> "People understand what they can see. If a programmer cannot see what a program is doing, she can't understand it."

I won't expand on these too much as Victor elaborates on them in the [original piece](http://worrydream.com/#!/LearnableProgramming) and provides plenty of tangible examples of how they might look in an interface. 

Victor's principles amount to a kind of [[Pattern Language]] - they're a set of design rules that define how a system should work.

Since Victor wrote his piece in 2012, the world of programming education has stepped up its visual game. It's no longer just two column, text-based execution contexts. We're now swimming in interactive visual environments and gamified educational platforms.

I began researching the field to see how many of them were putting Victor's principles into practice. The examples I looked at ranged from full-on illustrated games to lightly animated sequences of text. As I explored, I started to notice design patterns beyond the principles Victor outlined.

While Victor defined a set of ideals for a hypothetical learning platform, I became more interested in finding patterns in what already exists. While we're a long way from achieving the '_ideal_' system, there's plenty of good design happening here and now.

---

## A Pattern Language for Learnable, Visual Programming



#### 1. Location and Destination
The learner should always know where they are on the learning path, and what their destination is.

This one isn't specific to visual programming – it's a well-established principle of UX design that people need to know where they are, where they've been, and where they're headed.

Making this clear with a visual progress bar is common on learning platforms when we're trying to coax people through the long, hard journey of learning a new programming language or framework. It helps keep them motivated and feel a sense of regular progress. 

<Draft />

---

#### 2. Embodied Space over Symbols

Instead of one-dimentional abstract symbols and signs, use our embodied understanding of up, down, left, right, front, and back to map concepts to two-dimentional space.


#### 3. Immersive Focus

#### 4. Invitation to Explore

#### 5. Direction Connections

Create a direct, instant association between syntax commands and their effects

This is very similar to Victor's 'Read the Vocabulary'

In traditional programming interfaces there's a significant lag between writing syntax, waiting for code to compile, and seeing the change in a browser or printed logs. It's often unclear what _exactly_ changed, and what part of the code changed it.

#### 6. Keep It In Context

#### 7. Cry for Help

#### 8. Revisit the Past

#### 9. Put it in Your Pocket

#### 10. Flow Over Time

#### 11. Compare and Contrast

#### 12. Brownie Points

---

#### Flexbox Froggy and Grid Garden
[Flexbox Froggy](https://flexboxfroggy.com/) and [Grid Garden](https://cssgridgarden.com/) are built by [Codepip](https://codepip.com/) and both teach CSS layout techniques through live reactive demos. Every character you type into the code editor has an immediate reaction in the illustrated demo.  
This shortens the lag between action and reaction we usually have to deal with when waiting for code to compile, and makes it easier to figure out what each command does.

<FullWidthImage width="800px" src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174728/maggieappleton.com/notes/learnable-programming/Grid_Garden_-_A_game_for_learning_CSS_grid_a6ba49.png" />

<FullWidthImage width="800px" src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174725/maggieappleton.com/notes/learnable-programming/Screenshot_-_2021-02-15_22.58.17_jx3h6w.png" />

The same company made [CSS Diner](https://flukeout.github.io/) which takes a similar approach to teach CSS selectors. Every command you type instantly highlights what's being selected on the illustration.

<FullWidthImage width="800px" src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174727/maggieappleton.com/notes/learnable-programming/Screenshot_-_2020-06-29_13.47.26_iyq9a2.png" />

#### Vim Adventures

[Vim Adventures](https://vim-adventures.com/) uses the style of a platform game to help learners get comfortable with the essential commands of Vim. Making the metaphor of physical space more obvious by adding pathways and directions helps you think about Vim's interface as a spatial area instead of a regular linear text editor.

<FullWidthImage width="800px" src="https://res.cloudinary.com/dxj9qr5gj/image/upload/v1614174728/maggieappleton.com/notes/learnable-programming/Screenshot_-_2021-02-15_23.19.44_cez50t.png" />

#### Method of Action

While not strictly programming-related, the Bezier Game, the Boolean Game, and the Kerning Game...
